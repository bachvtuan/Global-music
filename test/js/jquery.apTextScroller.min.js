(function($) {

apTextScroller = function() {
	
	var _textField;
	var _scrolingSpeed;//speed which text moves (its enter frame based)
	var _mask;
	var _spaceString;//text inbetween main text
	var _oneLength;
	var _direction;
	var scrollInterval = 100;
	var scrollIntervalID;
	var scrollValue=0;
	var fontMeasure;
	var originalString, originalStringSize, scrollString;
	var _inited=false;
	
	//**************** CONSTRUCTOR
	
	this.init = function(fm, txt, mask, direction, spaceString, scrolingSpeed){
		fontMeasure=fm;
		_textField=txt;
		_mask = mask;
		_direction=direction;
		_spaceString=spaceString;
		_scrolingSpeed=scrolingSpeed;
	}	
	
	//**************** PUBLIC
	
	this.input = function(s) {
		//console.log('s = ', s);
		
		originalString = s;
		
		fontMeasure.html(s);
		originalStringSize=fontMeasure.width();
		//var w = fontMeasure.width();
		//var h = fontMeasure.height();
		
		var noSpace = s.replace(/\s/g, '&nbsp;');
		//console.log(noSpace);
		var t=noSpace + _spaceString;
		//console.log(t);
		
		_textField.html('');//reset
		_textField.css('width', 'auto');
		_textField.html(t);
		_oneLength=_textField.width();
		//console.log('_oneLength = ', _oneLength);
		if(_oneLength == 0) return;
		var size;
		var z=t;
		//we need to append so many times that its at least 2 oneLength's long.
		if (_oneLength <= _mask.width() * 2) {
			//trace(visibleSpace * 2 / oneLength);
			var limit=Math.floor(_mask.width() * 2 / _oneLength);///we lower it down because we already have one text inside.
			//console.log('limit = ', limit);
			for (var i=0; i < limit; i++) {
				z+=t;
			}
			size=_oneLength*(limit+1);
		} else {//the above loop didnt handle case if text is longer than visibleSpace * 2!,   then it wouldnt be copied at all and it still need to be copied once.
			z+=t;
			size=_oneLength*2;
		}
		_textField.html(z);
		_textField.css('width', size+1+'px');
		scrollString=z;

		/*if(_direction == "right"){//reverse words
		
		
		}*/
		
		_inited=true;
	}
	
	this.inputSingle = function(s) {
		//_textField.text = s;
		//_textField.x = 0;
	}
	
	this.activate = function() {
		//console.log('activate');
		this.deactivate();
		//console.log(_mask.width());
		if(_mask.width() >= originalStringSize){
			_textField.html(originalString);
		}else{
			_textField.html(scrollString);
			scrollIntervalID = setInterval(scrollText, scrollInterval);	
		}
	}
	
	this.deactivate = function() {
		//console.log('deactivate');
		if(scrollIntervalID) clearInterval(scrollIntervalID);
		if(_direction == "left"){//reset
			_textField.css('left', 0+'px');
			scrollValue=0;
		}
	}
	
	this.checkSize = function() {
		if(!_inited)return;
		//console.log(_mask.width(), originalStringSize);
		if(_mask.width() >= originalStringSize){
			this.deactivate();
			_textField.html(originalString);
		}else{
			_textField.html(scrollString);
			this.activate();
		}
	}
		
	//**************** PRIVATE
	
	function scrollText() {
		if (_direction == "left") {
			scrollValue -= _scrolingSpeed;
			//console.log(scrollValue);
			_textField.css('left', scrollValue+'px');
			if(parseInt(_textField.css('left'),10) < -_oneLength) {
				scrollValue=-_scrolingSpeed;//reset
			}
		} else {
			/*_textField.x+= _scrolingSpeed;
			if (_textField.x > 0) {
				_textField.x=- _oneLength + _scrolingSpeed;// because it should accomodate for the shift
			}*/
		}
	}
}

})(jQuery);